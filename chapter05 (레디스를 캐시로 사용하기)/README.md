# 05장 레디스를 캐시로 사용하기

## 레디스와 캐시

### 캐시란?
데이터의 원본보다 더 빠르고 효율적으로 엑세스할 수 있는 임시 데이터 저장소를 의미한다.

캐시를 도입했을 때 효과가 좋은 경우
- 원본 데이터 저장소에서 원하는 데이터를 찾기 위해 검색하는 시간이 오래 걸리거나 매번 계산을 통해 데이터를 가져와야 한다.
- 캐시에서 데이터를 가져오는 것이 원본 데이터 저장소 데이터를 요청하는 것보다 빨라야 한다.
- 캐시에 저장된 데이터는 잘 변하지 않는 데이터이다.
- 캐시에 저장된 데이터는 자주 검색되는 데이터이다.

### 캐시로서의 레디스

레디스는 모든 데이터를 메모리에 저장하는 인메모리 데이터 저장소이기 때문에 데이터를 검색하고 반환하는 것이 상당히 빠르다.

레디스는 자체적으로 고가용성 기능을 가지고 있다.  
센티널 또는 클러스터 기능을 사용하면 마스터 노드의 오류를 자동으로 감지해 페일오버를 발생시키기 때문에 관리자의 개입 없이 캐시가 정상적으로 유지될 수 있다.

클러스터를 사용하면 스케일 아웃 또한 쉽게 처리할 수 있다.

## 캐싱 전략

### 읽기 전략- look aside

애플리케이션은 찾고자 하는 데이터가 먼저 캐시에 있는지 확인  
데이터가 캐시에 있으면(캐시 히트) 캐시에서 데이터를 읽어옴

데이터가 없으면(캐시 미스) 애플리케이션은 직접 데이터베이스에 접근해 데이터를 가져와야 한다.

look aside 구조의 장점은 캐시에 문제가 생겨 접근을 할 수 없는 상황이더라도 서비스 장애로 이어지지 않고 DB에서 데이터를 가져올 수 있다는 것이다.

### 쓰기전략

캐시는 DB에 저장돼 있는 데이터를 단순히 복사해 온 값이다.  
따라서 원본 데이터와 동일한 값을 갖도록 유지하는 것이 필수적이다.

데이터 간 불일치를 캐시 불일치(Cache Inconsistency)라 한다.

#### write through

데이터베이스에 업데이트할 때마다 매번 캐시에도 데이터를 함께 업데이트시키는 방식이다.

캐시는 항상 최신 데이터를 가지고 있게 되지만, 데이터는 매번 2개의 저장소에 저장돼야 하기 때문에 데이터를 쓰는데에 시간이 많이 소요될 수 있다.

다시 사용되지 않을 데이터도 무조건 캐시에 저장되기 때문에 리소스 낭비가 발생할 수 있다.  
만료 시간을 사용하는 것이 좋다.

#### cache invalidation

데이터베이스에 값을 업데이트할 때마다 캐시에서는 데이터를 삭제하는 전략  
저장소에서 특정 데이터를 삭제하는 것이 데이터를 저장하는 것보다 리소스를 적게 사용하기 때문에

write through의 단점을 보완한 방법이라고 볼 수 있다.

#### write behind(write back)
대량의 쓰기 작업이 발생하면 많은 디스크 I/O가 발생해 성능 저하가 발생할 수 있다.

따라서 데이터를 빠르게 접근할 수 있는 캐시에 업데이트한 뒤, 비동기적으로 데이터베이스에 업데이트하는 것이다.

저장되는 데이터가 실시간으로 정확한 데이터가 아니어도 되는 경우 유용할 수 있다.  
예를 들어 유튜브 동영상 좋아요

## 캐시에서의 데이터 흐름

기본적으로 메모리는 서버의 스토리지보다 훨씬 적은 양을 보관할 수 밖에 없으므로  
적절한 TTL을 지정하는 것이 좋다.

### 만료 시간

만료 시간은 일반적으로 초 단위로 표현되며, 만료 시간이 지정된 키와 관련된 데이터는 지정된 시간이 지난 후 레디스에서 자동으로 삭제된다.

`EXPIRE` 커맨드를 사용하면 만료 시간을 설정할 수 있다.  
`TTL` 커맨드를 사용하면 키에 대한 만료 시간을 확인할 수 있다.

키존 기에 새로운 값을 저장해 키를 덮어 쓰면 이전에 설정한 만료 시간은 유지되지 않고 사라진다.

### 메모리 관리와 maxmemory-policy 설정

데이터의 최대 저장 용량을 설정하는 maxmemory 설정과 이 용량을 초과할 때의 처리 방식을 결정하는 maxmemory-policy 설정값을 사용해 메모리 관리를 할 수 있다.

#### Noeviction

레디스에 데이터가 가득 차더라도 임의로 데이터를 삭제하지 않고 더 이상 레디스에 데이터를 저장할 수 없다는 에러를 반환한다.

로직에 따라 장애 상황으로 이어질 수 있어 권장되지 않는다.

#### LRU eviction

데이터가 가득 찼을 때 가장 최근에 사용되지 않은 데이터부터 삭제하는 정책이다.

- volatile-lru

    만료 시간이 설정돼 있는 키에 한해서 LRU 방식으로 키를 삭제  
    만료 시간이 설정돼 있다는 것은 언젠가 삭제될 키라는 것

    하지만 저장된 키 모두에 만료 시간이 설정되어 있지 않다면 noeviction 상황이 되어 장애 발생 가능

- allkeys-lru

    모든 키에 대해 LRU 알고리즘으로 데이터를 삭제

#### LFU eviction

가장 자주 사용되지 않는 데이터부터 삭제.  
자주 사용되지 않은 데이터는 나중에도 엑세스될 가능성이 낮을 것이라는 가정을 전제로 함.

- volatile-lfu

    만료 시간이 설정된 키에 한해

- allkeys-lfu

    모든 키가 대상

#### RANDOM eviction

레디스에 저장된 키 중 하나를 임의로 골라내 삭제  
삭제될 키 값을 계산하지 않아도 되므로 부하가 적음

- volatile-random
- allkeys-random

#### volatile-ttl
만료 시간이 가장 작은 키를 삭제

### 캐시 스탬피드 현상
대규모 트래픽 환경에서 만료 시간을 어떻게 설정하느냐에 따라 캐시 스탬피드(Cache Stampede) 와 같은 문제 상황이 발생할 수 있다.

만약 여러 개의 애플리케이션에서 바라보던 키가 만료돼 삭제되면 서버들은 한꺼번에 데이터베이스에 가서 데이터를 읽어온다 (중복 읽기 / Duplicate Read)

이후 각 애플리케이션은 읽어온 데이터를 레디스에 쓰게 되는데, 여러 번 반복되기 때문에 중복 쓰기(Duplicate Write)가 발생

한번 캐시 스탬피드 현상이 발생하면 더 많은 데이터가 이 현상의 영향을 받게 돼, 계단식 실패(Cascading Failure)라고도 부른다.

#### 적절한 만료 시간 설정
여러 애플리케이션이 동시에 접근할 수 있고, 반복적으로 사용해야 하는 데이터라면 만료시간을 충분히 길게 설정하는 것이 도움이 된다.

#### 선 계산

키가 실제로 만료되기 전에 이 값을 미리 갱신해준다면, 캐시 스탬피드 현상을 줄일 수 있다.

```python
def fetch(key, expiry_gap): 
    ttl = redis.ttl(key)

    if ttl - (random() * expiry_gap) > 0:
        return redis.get(key)

    else:
        value = db.fetch(key)
        redis.set(value, KEY_TTL)
        return value

fetch('hello', 2)
```

랜덤한 확률로 키가 만료되기 전 데이터를 갱신  
단순하게 데이터를 갖고 오는 방법보다 더 많은 리소스를 사용한다고 볼 수도 있지만, 상황에 따라 캐시 스탬피드 현상을 줄일 수 있어 전체적인 성능을 향상시키는 방법일 수 있다.

#### PER 알고리즘

Probabilistic Early Recomputation 을 이용하면 캐시 값이 만료되기 전에 언제 데이터베이스에 접근해서 값을 읽어오면 되는지 최적으로 계산할 수 있다.

PER 알고리즘 간단요약
```
currentTime - ( timeToCompute * beta * log(rand()) ) > expiry
```

- currenTime: 현재 남은 만료 시간
- timeToCompute: 캐시된 값을 다시 계산하는데 걸리는 시간
- beta: 기본적으로 1, 0보다 큰 값으로 설정 가능
- expiry: 키를 재설정할 때 새로 넣어줄 만료 시간

만료 시간이 가까워질수록 조건이 참이 될 확률이 높아진다.

true를 반환하는 애플리케이션은 데이터를 다시 계산하기 위해 데이터베이스로 이동하게 된다.

## 세션 스토어로서의 레디스

### 세션이란?
서비스를 사용하는 클라이언트의 상태 정보

서비스에 로그인돼 있는 클라이언트가 누구인지, 어떤 활동을 하고 있는지 저장,  
유저가 서비스를 떠나면 세션 삭제

### 세션 스토어가 필요한 이유

서비스가 확장돼 웹 서버가 여러 대로 늘어나면 세션 스토어와 웹 서버 간의 종속성을 생각해야 한다.

특정 웹 서버와 세션 스토어가 종속되어 있다면, 특정 웹 서버에 유저가 몰려 트래픽이 집중되는 상황이 발생하더라도 유저는 다른 서버를 사용할 수 없어 트래픽을 분산 시킬 수 없다.  
이를 sticky session 이라고 한다.

유저의 세션 정보를 모든 웹 서버에 복제하여 저장하는 방법을 all-to-all 방법이라고 한다.

불필요한 저장 공간을 차지하게 되며, 하나의 유저는 한 번에 하나의 웹 서버에만 접속하기 때문에 다른 웹 서버에 저장된 유저의 세션 정보는 무의미하다.

유저는 세션이 활성화돼 있는 동안 세션 스토어에 활발하게 엑세스하므로 DB를 세션 스토어로 이용하는 것도 문제가 있다.

레디스를 세션 스토어로 사용해 서버, 데이터베이스와 분리시켜 놓은 뒤 여러 서버에서 세션 스토어를 바라보도록 구성한다면 앞선 이슈를 해결할 수 있다.

이 때 세션 스토어에 장애가 발생하면 내부 데이터가 손실될 가능성이 있으므로 레디스를 세션 스토어로 활용할 때에는 레디스를 캐시로 사용할 때보다 더 신중한 운영이 필요하다.