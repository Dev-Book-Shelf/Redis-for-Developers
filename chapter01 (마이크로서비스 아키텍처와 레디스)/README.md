# 01장 마이크로서비스 아키텍처와 레디스

## NoSQL의 등장 배경

지난 몇십 년 동안 디지털 산업의 엄청난 성장으로 인해 소프트웨어의 아키텍처는 중앙 집약적인 모놀리틱 아키텍처에서 마이크로서비스 아키텍처로 점차 변화하고 있다.

이에 따라 데이터 저장소의 특징 역시 다양하게 발전해왔다.

### 모놀리틱 아키텍처

![](https://www.f5.com/content/dam/www/blogs/2015/Richardson-microservices-part1-1_monolithic-architecture.png)

전통적인 소프트웨어 개발 모델로, 전체 애플리케이션을 하나의 통합된 패키지로 개발, 배포하는 방식.  
모든 시스템은 하나도 연결돼 관리된다.

작은 규모의 프로젝트나 애플리케이션에서는 모놀리틱 구조가 운영하기 쉬울 수 있으나, 규모가 확장되면 유지보수의 복잡도가 증가한다.  
또한 하나의 시스템에 문제가 생기면 전체 시스템의 장애로 이어진다.

하나의 모듈을 수정하면 전체 애플리케이션을 다시 배포해야 하며, 서버의 기동과 빌드, 배포에 드는 시간이 길어진다.

### 마이크로서비스 아키텍처

![](https://www.f5.com/content/dam/www/blogs/2015/Richardson-microservices-part1-2_microservices-architecture.png)

독립된 각각의 모듈을 조립해 하나의 서비스를 만드는 아키텍처

기능별로 작게 나뉘어진 서비스가 독립적으로 동작한다.  
업데이트, 테스트, 배포, 확장이 각 서비스별로 수행될 수 있다.

빠르게 성장하는 프로젝트라면 MSA를 채택하는 것이 도움이 될 수 있다.  
새로운 기능을 추가해 배포하는 것이 비교적 편리하기 때문에 요구사항에 민첩하게 대처할 수 있다.

한 서비스에서의 문제가 다른 서비스의 큰 영향을 주지 않아 운영의 안정성이 향상된다.

하지만 서비스 분리로 인한 관리의 복잡도와 운영 부담이 증가할 수 있다.

### 데이터 저장소 요구사항의 변화

그 동안 모놀리틱 서비스에서 애플리케이션 개발을 위해 가장 많이 사용된 데이터베이스는 Oracle, SQL Server, MySQL 등의 관계형 데이터베이스였다.

관계형 데이터베이스는 모든 데이터를 행과 열로 구성된 테이블에 저장하며, 각 테이블 간의 관계를 정확하게 규정한다.  
이러한 관계는 애플리케이션이 커질수록 매우 복잡해지며 데이터를 추출하기 위한 쿼리 또한 복잡해진다.  
성능 향상을 위해 쿼리, 인덱스, 테이블 구조를 자주 최적화해야 한다.

애플리케이션에서 사용하는 모든 데이터를 하나의 데이터베이스에서 관리하고자 했기 때문에 모놀리틱 아키텍처에서는 이런 중앙 집약적인 관계형 데이터베이스를 표준으로 삼아왔다.

하지만 최근의 서비스에서는 정해진 형태가 없고, 크기와 구조를 예측할 수 없는 비정형 데이터가 증가하고 있다.  
이러한 비정형 데이터는 다차원적이거나 깊은 계층 구조를 가질 수 있어 관계형 데이터베이스의 정형화된 테이블과는 맞지 않는다.

ex. 그래프 데이터, 실시간 로그 데이터 같은 시계열 데이터(잦은 read), JSON 데이터 등

또한 관계형 데이터베이스를 사용하는 일부 기업에서는 테이블 구조 변경을 위해 데이터 아키텍트(DA)의 승인을 거치고 DBA가 작업을 진행하는 데이터 관리 체계로 인해 개발 속도가 저하될 수 있다.

반면 NoSQL을 사용할 경우 개발 팀이 바로 데이터 구조를 바꿀 수 있어 더 빠른 개발이 가능하다.

비즈니스 특성과 데이터의 형태를 고려하지 않고 관계형 데이터베이스만을 고집한다면 복잡하고 비효율적인 데이터 모델을 갖는 시스템이 될 수도 있다는 것이다.

## NoSQL이란?

No SQL 혹은 Not Only SQL을 의미한다.  
관계형 데이터베이스에서 테이블의 데이터를 쿼리하기 위한 SQL을 사용하지 않는 데이터 저장소임을 내포한다.

기존 관계형 데이터베이스의 한계를 넘어서기 위해 새로 고안된 데이터베이스인 만큼, 마이크로서비스의 저장소로 쓰일 수 있도록 여러 요구사항을 만족시킨다.

### 실시간 응답

사람은 100ms가 넘어가면 지연이 있다고 인지  
마이크로서비스 내의 저장소에서는 빠른 응답 속도가 더욱 중요하다.  
각각의 개별 서비스가 빠르게 동작하지 않으면 서비스 자체가 병목 현상을 유발할 수 있기 때문

### 확장성

서비스의 업그레이드 같은 계획적 확장뿐만 아니라 예상치 못한 이벤트로 인한 트랜잭션의 증가에도 유연하게 확장할 수 있다.

### 고가용성

데이터 저장소를 사용할 수 없는 상황은 서비스의 장애로 이어진다.  
따라서 데이터 저장소는 장애 상황에서 신속하게 복구돼 항상 사용할 수 있는 상태를 유지해야 한다.

### 클라우드 네이티브

클라우드 제공 업체에서 제공하는 DBaas(DataBase-as-a-service)를 이용하면 직접 설치, 운영할 필요 없이 바로 사용할 수 있다.

### 단순성

MSA같이 서비스가 세분화될수록 관리 포인트는 늘어난다.  
개발자와 운영자는 데이터 저장소를 간단하게 사용하고 싶어한다.  
또한 한 가지의 데이터 모델이 모든 서비스에 딱 알맞게 최적화되지 않기 때문에 서비스별로 적절한 데이터 모델을 사용하길 원한다.

### 유연성

비정형 데이터를 적합한 방식으로 저장할 수 있다.

## NoSQL 데이터 저장소 유형

![](https://learn.microsoft.com/ko-kr/dotnet/architecture/cloud-native/media/types-of-nosql-datastores.png)

### 그래프

엔티티 간의 관계를 효율적으로 저장

저장되는 속성의 크기가 크거나 혹은 매우 많은 속성을 저장할 때는 적합하지 않다.

### 칼럼

칼럼 지향적(Column-Oriented) 또는 와이드 칼럼(Wide Column) 유형으로도 부르며, 데이터는 행이 아닌 열로 저장된다.

하나의 열에 중첩된 키-값 형태로 저장될 수 있기 때문에 기존 관계형 데이터베이스보다 유연한 스키마를 저장할 수 있다.

### 문서

JSON 형태로 데이터가 저장됨  
스키마가 따로 정해져 있지 않기 때문에 애플리케이션에 맞게 데이터를 그대로 저장할 수 있어 유연성이 크다.

모든 값은 항상 키와 연결되는 계층적 트리와 같은 구조를 갖는다.  
따라서 데이터를 저장하거나 검색하는데 효과적

### 키-값

가장 단순하고 빠르다.  
키를 사용해 값을 검색할 수 있으며, 키를 삭제하면 값도 삭제된다.

데이터의 저장이 간단하기 때문에 수평적 확장이 쉽고, 구조가 단순하여 빠른 데이터 엑세스와 처리 속도를 보장

## 레디스란?

REmote DIctionary Server 의 약자로, 고성능 키-값 유형 인메모리 NoSQL DB이다.

### 레디스의 특징

#### 실시간 응답(빠른 성능)

대부분의 데이터베이스는 온디스크  
자주 사용되는 데이터는 캐싱되어 메모리에 올라와 있는 경우도 있지만, 그렇지 않으면 디스크의 데이터를 페이지 단위로 메모리에 올린 뒤 메모리에서 데이터를 찾아야 한다.

인메모리 DB는 모든 데이터가 컴퓨터의 메모리에서 관리되어 데이터의 처리 성능이 빠르다.

#### 단순성

키에 매핑되는 값에 문자열 뿐만 아니라 hash, set 등 다양한 데이터 구조를 지원

레디스는 다양한 자료구조를 지원하여 임피던스 불일치(Impedance Mismatches; 관계형 데이터베이스의 테이블과 프로그래밍 언어 간 데이터 구조, 기능 차이로 인해 발생하는 충돌)를 해소

클라이언트의 요청은 단일 스레드로 처리되어 하나의 코어만 있는 환경에서도 레디스를 사용할 수 있어 배포가 쉽다.

동기화나 잠금 메커니즘 없이도 안정적이고 빠르게 사용자의 요청을 처리할 수 있다.

#### 고가용성

자체적으로 HA(High Availablility)를 제공

복제를 통해 데이터를 여러 서버에 분산시킬 수 있으며, 센티널(Sentinel)은 장애 상황을 탐지해 자동으로 Fail-Over 시켜준다.

#### 확장성

![Redis Cluster](https://cdn-ak.f.st-hatena.com/images/fotolife/q/quoll00/20200401/20200401024340.png)

레디스에서 클러스터 모드를 사용하면 수평적 확장이 쉽게 가능하다.

데이터는 레디스 클러스터 내에서 자동으로 샤딩된 후 저장되며, 여러 개의 복제본이 생성될 수 있다.

애플리케이션에서는 대상 데이터가 어떤 샤드에 있는지 신경 쓰지 않아도 되므로 레디스를 사용할 때와 동일하게 데이터를 가져오고 저장할 수 있다.

클러스터 구조에서 모든 레디스 인스턴스는 클러스터 버스라는 프로토콜을 이용해 서로를 감시하고 있으며, 클러스터의 마스터 노드에 문제가 발생하면 자동으로 페일오버를 시켜 고가용성을 유지할 수 있다.

#### 클라우드 네이티브 - 멀티 클라우드

클라우드 네이티브는 클라우드 환경에 특화된 애플리케이션의 개발 및 운영 방식을 의미

빠른 배포와 확장성, 높은 복원력을 중심으로 한 애플리케이션 추구

레디스는 빠른 데이터 엑세스, 처리를 지원하는 구조로 인해 MSA와의 연계에서 큰 장점을 지님

멀티 클라우드는 여러 클라우드 제공업체의 서비스를 동시에 또는 혼합해 활용하는 전략

단일 클라우드 환경의 장애나 제한된 자원에 대한 의존성을 줄인다.

또한 데이터가 특정 지역이나 국가 내에 물리적으로 위치하도록 조절할 수 있어 대기 시간을 줄이고, 장애에 더 강건하게 대응할 수 있다.

레디스는 멀티 클라우드 환경에서 일관된 성능과 기능을 제공하여 서비스의 연속성과 데이터의 일관성을 보장한다.

## 마이크로서비스 아키텍처와 레디스

모놀리틱 -> 마이크로서비스 아키텍처의 변화로 데이터 저장소의 요구 사항도 변화했으며, 더 이상 관계형 데이터베이스만으로는 모든 기능을 커버할 수 없다.

### 데이터 저장소로서의 레디스

레디스는 마이크로서비스 아키텍처에서 각 서비스별 개별 저장소로 사용하기에 알맞다.

간편한 설치, 적은 리소스 사용, 다양한 자료구조, 고가용성

메모리에 데이터가 저장되기 때문에 데이터의 영속성을 고민할 수 있으나, AOF(Append Only File), RDB(Redis DataBase) 형식으로 디스크에 주기적으로 저장할 수 있고, 장애가 발생해 데이터가 유실되더라도 백업 파일을 이용하면 다시 복구할 수 있다.

### 메시지 브로커로서의 레디스

메시징 큐 혹은 stream과 같은 메시지 브로커를 분리되어 있는 각 서비스간 통신 채널로 사용할 수 있다.

레디스의 pub/sub 기능은 가장 간단한 메시징 기능으로, fire-and-forget 패턴으로 동작하여 일회성 메시징 상황에 유용하게 사용할 수 있다.

레디스의 list 자료구조, stream 자료구조를 이용하여 메시징 큐/스트림으로 활용 가능하다.
